<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <title>Marco Lógico — Humana Brasil</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root{--green:#1E7E34;--ink:#1b1b1b;--bg:#fafafa;--muted:#667085}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:900px;margin:0 auto;padding:20px}
    header{text-align:center;padding:20px 0}
    h1{margin:0 0 6px;font-size:26px}
    .lead{color:var(--muted);margin:0 0 12px}
    form{background:#fff;border:1px solid #eee;border-radius:12px;padding:22px;box-shadow:0 2px 8px rgba(0,0,0,.04)}
    .form-section{margin-bottom:18px}
    label{display:block;margin:10px 0 6px;font-weight:600}
    input,textarea,select{width:100%;border:1px solid #d8dee4;border-radius:8px;padding:12px;font:inherit}
    textarea{resize:vertical;min-height:110px}
    .file-info{background:#f0f7f4;border-left:4px solid var(--green);padding:10px;border-radius:6px;margin:8px 0;font-size:13px}
    .objetivos-section{display:none}
    .objetivos-section.ativa{display:block}
    .objetivo-input-group{background:#f9f9f9;border:1px solid #e3e8ee;border-radius:8px;padding:12px;margin:8px 0}
    button{background:var(--green);color:#fff;border:0;border-radius:10px;padding:12px 20px;font-weight:600;cursor:pointer;font-size:16px;width:100%}
    button:disabled{opacity:.6;cursor:not-allowed}
    .status{min-height:22px;color:var(--muted);margin:12px 0 0;font-size:14px}
    .status.error{color:#d32f2f}
    .status.success{color:#1E7E34}
    .debug-info{background:#f5f5f5;border:1px solid #ddd;border-radius:8px;padding:12px;margin:12px 0;font-size:12px;font-family:monospace;max-height:400px;overflow-y:auto;display:none;white-space:pre-wrap;word-break:break-all}
    .debug-info.show{display:block}
  </style>
</head>
<body>
  <header class="wrap">
    <h1>Marco Lógico</h1>
    <p class="lead">Gerar a partir do edital e da proposta</p>
  </header>

  <main class="wrap">
    <form id="marcoForm" novalidate>
      <div class="form-section">
        <label>Arquivo do edital *
          <input type="file" id="edital" accept=".pdf,.docx,.txt" required>
        </label>
        <div id="editalInfo" class="file-info" style="display:none"></div>
      </div>

      <div class="form-section">
        <label>Nome do Projeto *
          <input id="nomeProjeto" type="text" required placeholder="Ex: Turismo Regenerativo na Ilha do Bananal">
        </label>
      </div>

      <div class="form-section">
        <label>Descrição da proposta *
          <textarea id="descricaoProposta" required placeholder="Contexto, atividades, público e resultados esperados"></textarea>
        </label>
      </div>

      <div class="form-section">
        <label>Quantidade de objetivos específicos *
          <select id="numObjetivos" required>
            <option value="">Selecione</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
          </select>
        </label>
      </div>

      <div class="form-section objetivos-section" id="objetivosSection">
        <div id="objetivosContainer"></div>
      </div>

      <button type="submit" id="submitBtn">Gerar marco lógico</button>
      <p id="status" class="status"></p>
      <div id="debugInfo" class="debug-info"></div>
    </form>
  </main>

  <script>
    const WEBHOOK_URL = 'https://hook.us2.make.com/SEU_WEBHOOK_AQUI'; /* troque pelo seu webhook */

    const form = document.getElementById('marcoForm');
    const editalInput = document.getElementById('edital');
    const editalInfo = document.getElementById('editalInfo');
    const numObjetivosSelect = document.getElementById('numObjetivos');
    const objetivosSection = document.getElementById('objetivosSection');
    const objetivosContainer = document.getElementById('objetivosContainer');
    const statusEl = document.getElementById('status');
    const submitBtn = document.getElementById('submitBtn');
    const debugInfo = document.getElementById('debugInfo');

    let editalConteudo = '';

    // Função para limpar e sanitizar strings
    function sanitizeString(str) {
      if (str == null) return '';
      return String(str)
        .replace(/\uFEFF/g, '') // Remove BOM
        .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') // Remove caracteres de controle
        .replace(/\r?\n/g, ' ') // Substitui quebras de linha por espaços
        .replace(/\s+/g, ' ') // Normaliza múltiplos espaços
        .trim();
    }

    // Função para preparar objetivos para envio
    function objetivosToOneLine(arr) {
      if (!Array.isArray(arr)) return '';
      return arr.map(o => {
        const titulo = sanitizeString(o.titulo).replace(/"/g, '\\"');
        const descricao = sanitizeString(o.descricao).replace(/"/g, '\\"');
        return `${o.numero}. ${titulo} | ${descricao}`;
      }).join(' || ');
    }

    /**
     * Parser JSON completamente reescrito - corrige caractere por caractere
     */
    function deepFixJSON(jsonStr) {
      console.log('=== DEEP FIX JSON INICIADO ===');
      
      let result = [];
      let i = 0;
      let inString = false;
      let escapeNext = false;
      let depth = 0;
      let structure = []; // pilha para rastrear se estamos em objeto {} ou array []
      
      // Pre-processamento: normaliza caracteres problemáticos
      jsonStr = jsonStr
        .replace(/\uFEFF/g, '')
        .replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F]/g, '')
        .replace(/[""]/g, '"')
        .replace(/['']/g, "'");
      
      // Rastreia o contexto para adicionar vírgulas quando necessário
      let lastNonWhitespaceChar = '';
      let lastSignificantChar = ''; // último char significativo (não whitespace, não vírgula)
      
      while (i < jsonStr.length) {
        let char = jsonStr[i];
        let nextChar = i < jsonStr.length - 1 ? jsonStr[i + 1] : '';
        let prevChar = i > 0 ? jsonStr[i - 1] : '';
        
        // Skip de escape
        if (escapeNext) {
          result.push(char);
          escapeNext = false;
          i++;
          continue;
        }
        
        // Tratamento de strings
        if (char === '"' && !escapeNext) {
          // Verifica se precisamos adicionar vírgula antes da string
          if (!inString && lastSignificantChar && 
              (lastSignificantChar === '"' || lastSignificantChar === '}' || lastSignificantChar === ']') &&
              structure.length > 0) {
            // Adiciona vírgula se não tiver
            let lastFewChars = result.slice(-10).join('');
            if (!lastFewChars.match(/[,\[\{]\s*$/)) {
              result.push(',');
            }
          }
          
          inString = !inString;
          result.push(char);
          if (!inString) {
            lastSignificantChar = '"';
          }
          i++;
          continue;
        }
        
        // Dentro de string
        if (inString) {
          if (char === '\\') {
            escapeNext = true;
            result.push(char);
          } else if (char === '\n' || char === '\r' || char === '\t') {
            // Substitui quebras de linha por espaço dentro de strings
            result.push(' ');
          } else {
            result.push(char);
          }
          i++;
          continue;
        }
        
        // Fora de strings - tratamento estrutural
        
        // Skip whitespace mas mantém rastreio
        if (/\s/.test(char)) {
          result.push(char);
          i++;
          continue;
        }
        
        // Abertura de objeto
        if (char === '{') {
          // Verifica se precisa vírgula antes
          if (lastSignificantChar && 
              (lastSignificantChar === '}' || lastSignificantChar === ']' || lastSignificantChar === '"') &&
              structure.length > 0 && structure[structure.length - 1] === '[') {
            let lastFewChars = result.slice(-10).join('');
            if (!lastFewChars.match(/[,\[\{]\s*$/)) {
              result.push(',');
            }
          }
          
          result.push(char);
          structure.push('{');
          depth++;
          lastSignificantChar = '{';
          lastNonWhitespaceChar = '{';
          i++;
          continue;
        }
        
        // Abertura de array
        if (char === '[') {
          // Verifica se precisa vírgula antes
          if (lastSignificantChar && 
              (lastSignificantChar === '}' || lastSignificantChar === ']' || lastSignificantChar === '"') &&
              structure.length > 0 && structure[structure.length - 1] === '[') {
            let lastFewChars = result.slice(-10).join('');
            if (!lastFewChars.match(/[,\[\{:]\s*$/)) {
              result.push(',');
            }
          }
          
          result.push(char);
          structure.push('[');
          depth++;
          lastSignificantChar = '[';
          lastNonWhitespaceChar = '[';
          i++;
          continue;
        }
        
        // Fechamento de objeto
        if (char === '}') {
          // Remove vírgula trailing se houver
          let j = result.length - 1;
          while (j >= 0 && /\s/.test(result[j])) j--;
          if (result[j] === ',') {
            result.splice(j, 1);
          }
          
          result.push(char);
          structure.pop();
          depth--;
          lastSignificantChar = '}';
          lastNonWhitespaceChar = '}';
          i++;
          continue;
        }
        
        // Fechamento de array
        if (char === ']') {
          // Remove vírgula trailing se houver
          let j = result.length - 1;
          while (j >= 0 && /\s/.test(result[j])) j--;
          if (result[j] === ',') {
            result.splice(j, 1);
          }
          
          result.push(char);
          structure.pop();
          depth--;
          lastSignificantChar = ']';
          lastNonWhitespaceChar = ']';
          i++;
          continue;
        }
        
        // Vírgula
        if (char === ',') {
          // Não adiciona vírgula duplicada
          let j = result.length - 1;
          while (j >= 0 && /\s/.test(result[j])) j--;
          if (result[j] !== ',') {
            result.push(char);
          }
          lastNonWhitespaceChar = ',';
          i++;
          continue;
        }
        
        // Dois pontos
        if (char === ':') {
          result.push(char);
          lastNonWhitespaceChar = ':';
          i++;
          continue;
        }
        
        // Outros caracteres (números, true, false, null)
        result.push(char);
        if (!/\s/.test(char)) {
          lastNonWhitespaceChar = char;
          // Atualiza lastSignificantChar para números e valores
          if (/[0-9\-]/.test(char) || char === 't' || char === 'f' || char === 'n') {
            // Captura o valor completo (número, true, false, null)
            let valueStr = char;
            let k = i + 1;
            while (k < jsonStr.length && /[a-z0-9.\-]/.test(jsonStr[k])) {
              valueStr += jsonStr[k];
              k++;
            }
            if (valueStr === 'true' || valueStr === 'false' || valueStr === 'null' || /^-?\d+(\.\d+)?$/.test(valueStr)) {
              lastSignificantChar = 'value';
            }
          }
        }
        i++;
      }
      
      // Fecha estruturas não fechadas
      while (structure.length > 0) {
        let openChar = structure.pop();
        if (openChar === '{') {
          result.push('}');
        } else if (openChar === '[') {
          result.push(']');
        }
      }
      
      // Fecha string não terminada se houver
      if (inString) {
        result.push('"');
      }
      
      let fixed = result.join('');
      
      console.log('JSON após deep fix (primeiros 500 chars):', fixed.substring(0, 500));
      
      return fixed;
    }

    /**
     * Parser principal melhorado
     */
    function parseMarcoResponse(rawResponse) {
      console.log('=== INICIANDO PARSE DO JSON ===');
      console.log('Tamanho da resposta:', rawResponse.length);
      
      try {
        // Etapa 1: Limpar marcadores de código
        let jsonStr = String(rawResponse || '').trim();
        jsonStr = jsonStr.replace(/^```json\s*/gi, '');
        jsonStr = jsonStr.replace(/^```\s*/gi, '');
        jsonStr = jsonStr.replace(/```\s*$/gi, '');
        
        // Etapa 2: Encontrar o início do JSON
        let startIndex = -1;
        const patterns = [
          '{"marco_logico"',
          '{ "marco_logico"',
          '{\n"marco_logico"',
          '{"',
          '{'
        ];
        
        for (let pattern of patterns) {
          startIndex = jsonStr.indexOf(pattern);
          if (startIndex >= 0) break;
        }
        
        if (startIndex === -1) {
          throw new Error('Não foi possível encontrar o início do JSON');
        }
        
        jsonStr = jsonStr.substring(startIndex);
        
        // Etapa 3: Aplicar deep fix
        jsonStr = deepFixJSON(jsonStr);
        
        // Etapa 4: Tentar parse
        let parsed;
        try {
          parsed = JSON.parse(jsonStr);
        } catch (e1) {
          console.error('Primeiro parse falhou:', e1.message);
          
          // Tenta correção adicional mais agressiva
          jsonStr = jsonStr
            .replace(/,\s*([}\]])/g, '$1') // Remove vírgulas antes de fechamento
            .replace(/([}\]])(\s*)(["{])/g, '$1,$2$3') // Adiciona vírgulas entre elementos
            .replace(/":\s*"([^"]*)"([^,}\]]*[}\]])/g, '": "$1"$2') // Corrige valores de string
            .replace(/\\\\/g, '\\') // Corrige double escapes
            .replace(/\\'/g, "'"); // Corrige escapes desnecessários
          
          try {
            parsed = JSON.parse(jsonStr);
          } catch (e2) {
            console.error('Segundo parse falhou:', e2.message);
            
            // Última tentativa: extrair apenas o marco_logico
            try {
              // Tenta extrair o objeto marco_logico usando regex
              const marcoMatch = jsonStr.match(/"marco_logico"\s*:\s*(\{[^]*\})\s*\}/);
              if (marcoMatch) {
                const marcoContent = marcoMatch[1];
                parsed = {
                  marco_logico: JSON.parse(marcoContent)
                };
              } else {
                // Tenta criar uma estrutura mínima válida
                console.log('Criando estrutura mínima...');
                parsed = {
                  marco_logico: {
                    objetivo_geral: "Objetivo não pôde ser extraído",
                    objetivos_especificos: []
                  }
                };
              }
            } catch (e3) {
              // Se tudo falhar, mostra o JSON problemático para debug
              console.error('Todas as tentativas falharam');
              debugInfo.innerHTML = `
<strong>ERRO CRÍTICO NO PARSE JSON</strong>

Posição do erro: ${e1.message}

<strong>JSON Processado (primeiros 2000 caracteres):</strong>
${jsonStr.substring(0, 2000)}

<strong>JSON em torno da posição do erro (pos 8497 ± 200):</strong>
${jsonStr.substring(8297, 8697)}

<strong>Sugestões:</strong>
1. Verifique se o webhook do Make está configurado corretamente
2. Verifique se o Make está retornando um JSON válido
3. Considere simplificar o prompt para gerar JSONs menores
4. Verifique se há caracteres especiais não escapados no conteúdo
              `;
              debugInfo.classList.add('show');
              
              throw new Error(`Parse JSON impossível. ${e1.message}`);
            }
          }
        }
        
        // Validação final
        if (!parsed || typeof parsed !== 'object') {
          throw new Error('Resposta não é um objeto válido');
        }
        
        if (!parsed.marco_logico) {
          console.warn('Campo marco_logico não encontrado, criando estrutura padrão...');
          parsed = {
            marco_logico: parsed
          };
        }
        
        console.log('=== PARSE CONCLUÍDO COM SUCESSO ===');
        return parsed;
        
      } catch (error) {
        console.error('Erro fatal no parse:', error);
        throw error;
      }
    }

    // Função para ler PDF
    async function lerPDF(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        
        let texto = '';
        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
          const page = await pdf.getPage(pageNum);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map(item => item.str).join(' ');
          texto += pageText + ' ';
        }
        
        return sanitizeString(texto);
      } catch (error) {
        console.error('Erro ao ler PDF:', error);
        throw new Error('Erro ao processar PDF: ' + error.message);
      }
    }

    // Função para ler DOCX
    async function lerDOCX(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
        return sanitizeString(result.value);
      } catch (error) {
        console.error('Erro ao ler DOCX:', error);
        throw new Error('Erro ao processar DOCX: ' + error.message);
      }
    }

    // Event listener para upload do arquivo
    editalInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      statusEl.textContent = 'Lendo arquivo...';
      statusEl.classList.remove('error', 'success');
      debugInfo.classList.remove('show');
      
      try {
        const fileName = file.name.toLowerCase();
        
        if (fileName.endsWith('.txt') || file.type === 'text/plain') {
          editalConteudo = await file.text();
        } else if (fileName.endsWith('.pdf') || file.type === 'application/pdf') {
          editalConteudo = await lerPDF(file);
        } else if (fileName.endsWith('.docx') || fileName.endsWith('.doc')) {
          editalConteudo = await lerDOCX(file);
        } else {
          throw new Error('Formato não suportado. Use PDF, DOCX ou TXT.');
        }
        
        editalConteudo = sanitizeString(editalConteudo);
        
        if (!editalConteudo || editalConteudo.length < 10) {
          throw new Error('Arquivo vazio ou com conteúdo insuficiente');
        }
        
        editalInfo.style.display = 'block';
        editalInfo.textContent = `✓ ${file.name} carregado com sucesso (${(editalConteudo.length / 1024).toFixed(1)} KB)`;
        statusEl.textContent = '';
      } catch (error) {
        statusEl.textContent = 'Erro ao ler arquivo: ' + error.message;
        statusEl.classList.add('error');
        editalInfo.style.display = 'none';
        editalConteudo = '';
      }
    });

    // Event listener para seleção de número de objetivos
    numObjetivosSelect.addEventListener('change', (e) => {
      const numObjetivos = parseInt(e.target.value) || 0;
      objetivosContainer.innerHTML = '';
      
      if (numObjetivos > 0) {
        objetivosSection.classList.add('ativa');
        
        for (let i = 1; i <= numObjetivos; i++) {
          const div = document.createElement('div');
          div.className = 'objetivo-input-group';
          div.innerHTML = `
            <strong>Objetivo Específico ${i}</strong>
            <input type="text" name="oe_titulo_${i}" placeholder="Título do objetivo ${i}" required>
            <textarea name="oe_descricao_${i}" placeholder="Descrição detalhada do objetivo ${i}" required></textarea>
          `;
          objetivosContainer.appendChild(div);
        }
      } else {
        objetivosSection.classList.remove('ativa');
      }
    });

    // Event listener para submissão do formulário
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      // Limpa debug anterior
      debugInfo.classList.remove('show');
      debugInfo.innerHTML = '';
      
      // Validações
      if (!editalConteudo) {
        statusEl.textContent = 'Por favor, carregue o arquivo do edital';
        statusEl.classList.add('error');
        return;
      }
      
      const nomeProjeto = sanitizeString(document.getElementById('nomeProjeto').value);
      const descricaoProposta = sanitizeString(document.getElementById('descricaoProposta').value);
      const numObjetivos = parseInt(numObjetivosSelect.value) || 0;
      
      if (!nomeProjeto || !descricaoProposta || !numObjetivos) {
        statusEl.textContent = 'Por favor, preencha todos os campos obrigatórios';
        statusEl.classList.add('error');
        return;
      }
      
      // Coleta objetivos específicos
      const objetivosEspecificos = [];
      for (let i = 1; i <= numObjetivos; i++) {
        const titulo = sanitizeString(form[`oe_titulo_${i}`].value);
        const descricao = sanitizeString(form[`oe_descricao_${i}`].value);
        
        if (!titulo || !descricao) {
          statusEl.textContent = `Por favor, preencha completamente o objetivo ${i}`;
          statusEl.classList.add('error');
          return;
        }
        
        objetivosEspecificos.push({
          numero: i,
          titulo: titulo,
          descricao: descricao
        });
      }
      
      // Prepara payload
      const payload = {
        edital: editalConteudo,
        nomeProjeto: nomeProjeto,
        descricaoProposta: descricaoProposta,
        objetivosEspecificos: objetivosEspecificos,
        objetivosEspecificosTexto: objetivosToOneLine(objetivosEspecificos)
      };
      
      try {
        submitBtn.disabled = true;
        statusEl.textContent = 'Enviando dados para processamento...';
        statusEl.classList.remove('error', 'success');
        
        // Envia request
        const response = await fetch(WEBHOOK_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json, text/plain'
          },
          body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
          throw new Error(`Erro HTTP: ${response.status} ${response.statusText}`);
        }
        
        statusEl.textContent = 'Processando resposta da IA...';
        
        const responseText = await response.text();
        console.log('Resposta recebida. Tamanho:', responseText.length);
        
        // Parse da resposta
        const parsedResponse = parseMarcoResponse(responseText);
        
        // Gera o arquivo XLSX
        statusEl.textContent = 'Gerando arquivo Excel...';
        gerarXLSX(parsedResponse, nomeProjeto);
        
        statusEl.textContent = '✓ Marco Lógico gerado com sucesso! O download deve iniciar automaticamente.';
        statusEl.classList.add('success');
        
      } catch (error) {
        console.error('Erro completo:', error);
        statusEl.textContent = `Erro: ${error.message}`;
        statusEl.classList.add('error');
        
        if (!debugInfo.classList.contains('show')) {
          // Se ainda não mostrou debug específico, mostra erro genérico
          debugInfo.innerHTML = `
<strong>Erro no processamento</strong>

${error.message}

<strong>Possíveis soluções:</strong>
1. Verifique se o webhook está configurado corretamente
2. Tente novamente com um texto menor no edital
3. Simplifique as descrições dos objetivos
4. Entre em contato com o suporte se o erro persistir

<strong>Stack trace:</strong>
${error.stack}
          `;
          debugInfo.classList.add('show');
        }
      } finally {
        submitBtn.disabled = false;
      }
    });

    // Função para gerar XLSX com tratamento robusto
    function gerarXLSX(responseData, nomeProjeto) {
      try {
        const marco = responseData.marco_logico || {};
        const objetivos = Array.isArray(marco.objetivos_especificos) ? marco.objetivos_especificos : [];
        
        // Cria novo workbook
        const wb = XLSX.utils.book_new();
        
        // Calcula estatísticas
        let totalResultados = 0;
        let totalIndicadores = 0;
        let totalAtividades = 0;
        
        objetivos.forEach(objetivo => {
          const resultados = Array.isArray(objetivo.resultados) ? objetivo.resultados : [];
          totalResultados += resultados.length;
          
          resultados.forEach(resultado => {
            const indicadores = Array.isArray(resultado.indicadores) ? resultado.indicadores : [];
            const atividades = Array.isArray(resultado.atividades) ? resultado.atividades : [];
            totalIndicadores += indicadores.length;
            totalAtividades += atividades.length;
          });
        });
        
        // Aba 1: Resumo
        const resumoData = [
          ['MARCO LÓGICO - RESUMO EXECUTIVO'],
          [''],
          ['Informações do Projeto'],
          ['Nome do Projeto:', nomeProjeto || 'Não especificado'],
          ['Objetivo Geral:', sanitizeString(marco.objetivo_geral || 'Não especificado')],
          ['Data de Geração:', new Date().toLocaleDateString('pt-BR') + ' ' + new Date().toLocaleTimeString('pt-BR')],
          [''],
          ['Estatísticas do Marco Lógico'],
          ['Objetivos Específicos:', objetivos.length],
          ['Resultados Esperados:', totalResultados],
          ['Indicadores:', totalIndicadores],
          ['Atividades:', totalAtividades],
          [''],
          ['Status:', 'Documento gerado automaticamente via IA']
        ];
        
        const wsResumo = XLSX.utils.aoa_to_sheet(resumoData);
        wsResumo['!cols'] = [
          { wch: 30 },
          { wch: 60 }
        ];
        
        XLSX.utils.book_append_sheet(wb, wsResumo, 'Resumo');
        
        // Aba 2: Marco Lógico Completo
        const marcoData = [
          ['OBJETIVO ESPECÍFICO', 'RESULTADO ESPERADO', 'INDICADOR', 'META', 'ATIVIDADE', 'LÓGICA DE INTERVENÇÃO', 'PRAZO', 'MEIOS DE VERIFICAÇÃO']
        ];
        
        if (objetivos.length === 0) {
          marcoData.push(['Nenhum objetivo específico encontrado', '', '', '', '', '', '', '']);
        } else {
          objetivos.forEach((objetivo, objIndex) => {
            const tituloObjetivo = sanitizeString(objetivo.titulo || objetivo.descricao || `Objetivo ${objIndex + 1}`);
            const resultados = Array.isArray(objetivo.resultados) ? objetivo.resultados : [];
            
            if (resultados.length === 0) {
              marcoData.push([tituloObjetivo, 'Sem resultados definidos', '', '', '', '', '', '']);
            } else {
              resultados.forEach((resultado, resIndex) => {
                const tituloResultado = sanitizeString(resultado.titulo || resultado.descricao || `Resultado ${resIndex + 1}`);
                const indicadores = Array.isArray(resultado.indicadores) ? resultado.indicadores : [];
                const atividades = Array.isArray(resultado.atividades) ? resultado.atividades : [];
                
                const maxRows = Math.max(indicadores.length, atividades.length, 1);
                
                for (let i = 0; i < maxRows; i++) {
                  const indicador = indicadores[i] || {};
                  const atividade = atividades[i] || {};
                  
                  marcoData.push([
                    i === 0 ? tituloObjetivo : '',
                    i === 0 ? tituloResultado : '',
                    sanitizeString(indicador.texto || indicador.descricao || indicador.nome || ''),
                    sanitizeString(indicador.meta || indicador.valor || ''),
                    sanitizeString(atividade.descricao || atividade.titulo || atividade.nome || ''),
                    sanitizeString(atividade.logica_intervencao || atividade.logica || ''),
                    sanitizeString(atividade.prazo || atividade.periodo || ''),
                    sanitizeString(atividade.meios_verificacao || atividade.verificacao || indicador.meios_verificacao || '')
                  ]);
                }
              });
            }
          });
        }
        
        const wsMarco = XLSX.utils.aoa_to_sheet(marcoData);
        wsMarco['!cols'] = [
          { wch: 25 },
          { wch: 25 },
          { wch: 30 },
          { wch: 15 },
          { wch: 30 },
          { wch: 25 },
          { wch: 12 },
          { wch: 20 }
        ];
        
        XLSX.utils.book_append_sheet(wb, wsMarco, 'Marco Lógico');
        
        // Gera nome único
        const timestamp = new Date().getTime();
        const nomeArquivoSeguro = nomeProjeto.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 50);
        const nomeArquivo = `Marco_Logico_${nomeArquivoSeguro}_${timestamp}.xlsx`;
        
        // Salva o arquivo
        XLSX.writeFile(wb, nomeArquivo);
        
        console.log('Arquivo XLSX gerado com sucesso:', nomeArquivo);
        
      } catch (error) {
        console.error('Erro ao gerar XLSX:', error);
        throw new Error('Erro ao gerar arquivo Excel: ' + error.message);
      }
    }

    // Logger para debug em desenvolvimento
    window.addEventListener('error', (e) => {
      console.error('Erro global:', e);
    });
  </script>
</body>
</html>
