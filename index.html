<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <title>Marco Lógico — Humana Brasil</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root{--green:#1E7E34;--ink:#1b1b1b;--bg:#fafafa;--muted:#667085}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:900px;margin:0 auto;padding:20px}
    header{text-align:center;padding:20px 0}
    h1{margin:0 0 6px;font-size:26px}
    .lead{color:var(--muted);margin:0 0 12px}
    form{background:#fff;border:1px solid #eee;border-radius:12px;padding:22px;box-shadow:0 2px 8px rgba(0,0,0,.04)}
    .form-section{margin-bottom:18px}
    label{display:block;margin:10px 0 6px;font-weight:600}
    input,textarea,select{width:100%;border:1px solid #d8dee4;border-radius:8px;padding:12px;font:inherit}
    textarea{resize:vertical;min-height:110px}
    .file-info{background:#f0f7f4;border-left:4px solid var(--green);padding:10px;border-radius:6px;margin:8px 0;font-size:13px}
    .objetivos-section{display:none}
    .objetivos-section.ativa{display:block}
    .objetivo-input-group{background:#f9f9f9;border:1px solid #e3e8ee;border-radius:8px;padding:12px;margin:8px 0}
    button{background:var(--green);color:#fff;border:0;border-radius:10px;padding:12px 20px;font-weight:600;cursor:pointer;font-size:16px;width:100%}
    button:disabled{opacity:.6;cursor:not-allowed}
    .status{min-height:22px;color:var(--muted);margin:12px 0 0;font-size:14px}
    .status.error{color:#d32f2f}
    .status.success{color:#1E7E34}
  </style>
</head>
<body>
  <header class="wrap">
    <h1>Marco Lógico</h1>
    <p class="lead">Gerar a partir do edital e da proposta</p>
  </header>

  <main class="wrap">
    <form id="marcoForm" novalidate>
      <div class="form-section">
        <label>Arquivo do edital *
          <input type="file" id="edital" accept=".pdf,.docx,.txt" required>
        </label>
        <div id="editalInfo" class="file-info" style="display:none"></div>
      </div>

      <div class="form-section">
        <label>Nome do Projeto *
          <input id="nomeProjeto" type="text" required placeholder="Ex: Turismo Regenerativo na Ilha do Bananal">
        </label>
      </div>

      <div class="form-section">
        <label>Descrição da proposta *
          <textarea id="descricaoProposta" required placeholder="Contexto, atividades, público e resultados esperados"></textarea>
        </label>
      </div>

      <div class="form-section">
        <label>Quantidade de objetivos específicos *
          <select id="numObjetivos" required>
            <option value="">Selecione</option>
            <option value="2">2</option><option value="3">3</option><option value="4">4</option><option value="5">5</option>
          </select>
        </label>
      </div>

      <div class="form-section objetivos-section" id="objetivosSection">
        <div id="objetivosContainer"></div>
      </div>

      <button type="submit" id="submitBtn">Gerar marco lógico</button>
      <p id="status" class="status"></p>
    </form>
  </main>

  <script>
    const WEBHOOK_URL = 'https://hook.us2.make.com/SEU_WEBHOOK_AQUI'; /* troque */

    const form = document.getElementById('marcoForm');
    const editalInput = document.getElementById('edital');
    const editalInfo = document.getElementById('editalInfo');
    const numObjetivosSelect = document.getElementById('numObjetivos');
    const objetivosSection = document.getElementById('objetivosSection');
    const objetivosContainer = document.getElementById('objetivosContainer');
    const statusEl = document.getElementById('status');
    const submitBtn = document.getElementById('submitBtn');

    let editalConteudo = '';

    function s(t){return String(t??'').replace(/\uFEFF/g,'').replace(/\r?\n/g,' ').trim();}
    function objetivosToOneLine(arr){
      if(!Array.isArray(arr)) return '';
      const clean=v=>String(v??'').replace(/[\r\n]+/g,' ').replace(/"/g,'\\"').trim();
      return arr.map(o=>`${o.numero}. ${clean(o.titulo)} | ${clean(o.descricao)}`).join(' || ');
    }

    // Isola substring JSON equilibrada a partir de um índice, ignorando chaves dentro de strings
    function sliceBalancedFrom(src, startIdx){
      let inStr=false, esc=false, depth=0, started=false;
      for(let i=startIdx;i<src.length;i++){
        const ch=src[i];
        if(inStr){
          if(esc){esc=false;}
          else if(ch==='\\'){esc=true;}
          else if(ch=== '"'){inStr=false;}
        }else{
          if(ch=== '"'){inStr=true;}
          else if(ch==='{'){depth++;started=true;}
          else if(ch==='}'){depth--; if(started&&depth===0){return src.slice(startIdx, i+1);} }
        }
      }
      return null;
    }

    // Corrige JSON de forma segura, operando fora de strings e com pilha de colchetes/chaves
    function safeFixJSON(jsonStr){
      const s = String(jsonStr);
      let out=[], stack=[];
      let inStr=false, esc=false;

      const isSpace=c=>c===' '||c==='\t'||c==='\r'||c==='\n';
      const lastNonSpace=()=>{
        for(let k=out.length-1;k>=0;k--){const c=out[k]; if(!isSpace(c)) return c;}
        return '';
      };

      for(let i=0;i<s.length;i++){
        let ch=s[i];

        // estado de string
        if(inStr){
          out.push(ch);
          if(esc){esc=false;}
          else if(ch==='\\'){esc=true;}
          else if(ch==='"'){inStr=false;}
          continue;
        }

        // fora de string
        if(ch==='"'){inStr=true; out.push(ch); continue;}

        // remover caracteres de controle
        if(ch<' ' && ch!=='\t' && ch!==' ') continue;

        // normalizar aspas tipográficas fora de string (não deveria ocorrer)
        if(ch==='“'||ch==='”'){ch='"';}
        if(ch==='‘'||ch==='’'){ch="'";}

        // pilha
        const top = stack.length?stack[stack.length-1]:null;

        // rule: se '{' vier após '}' ou ']' dentro de array, injeta vírgula
        if(ch==='{'||ch==='['){
          const prev=lastNonSpace();
          if((prev==='}'||prev===']') && top==='['){
            if(out[out.length-1]!==','){out.push(',');}
          }
          out.push(ch);
          stack.push(ch);
          continue;
        }

        // fecha pilha
        if(ch==='}'||ch===']'){
          // remover vírgula à direita antes de fechar, se existir
          let k=out.length-1; while(k>=0 && isSpace(out[k])) k--;
          if(out[k]===','){out.splice(k,1);} // remove trailing comma
          out.push(ch);
          const popped = stack.pop();
          // sanity: se mismatch, ignora
          continue;
        }

        // vírgula: se próxima não-espaço for '}' ou ']', não escreve (trailing)
        if(ch===','){
          let j=i+1;
          while(j<s.length && isSpace(s[j])) j++;
          const nxt = s[j];
          if(nxt==='}'||nxt===']'){ /* skip */ }
          else{ out.push(','); }
          continue;
        }

        // outros caracteres
        out.push(ch);
      }

      return out.join('');
    }

    // Parser final: limpa cercas, isola objeto, corrige com safeFixJSON e faz JSON.parse
    function parseMarco(raw){
      let t = String(raw||'')
        .replace(/^\s*json\s+/i,'')
        .replace(/```json|```/gi,'')
        .replace(/\uFEFF/g,'')
        .replace(/\r?\n/g,' ')
        .trim();

      // preferir ancora "{"marco_logico"
      let start = t.indexOf('{"marco_logico"');
      if(start<0) start = t.indexOf('{');
      if(start<0) throw new Error('Estrutura JSON inválida');

      // extrair bloco balanceado real
      const block = sliceBalancedFrom(t, start);
      if(!block) throw new Error('Estrutura JSON inválida');

      // corrigir somente o bloco isolado
      const fixed = safeFixJSON(block);
      const obj = JSON.parse(fixed);
      if(!obj || !obj.marco_logico) throw new Error('Estrutura JSON inválida');
      return obj;
    }

    async function lerPDF(file){
      const buf=await file.arrayBuffer();
      pdfjsLib.GlobalWorkerOptions.workerSrc='https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      const pdf=await pdfjsLib.getDocument({data:buf}).promise;
      let t=''; for(let p=1;p<=pdf.numPages;p++){const pg=await pdf.getPage(p);const c=await pg.getTextContent();t+=c.items.map(i=>i.str).join(' ')+' ';} return t;
    }
    async function lerDOCX(file){
      const buf=await file.arrayBuffer();
      const r=await mammoth.extractRawText({arrayBuffer:buf});
      return r.value;
    }

    editalInput.addEventListener('change', async e=>{
      const f=e.target.files[0]; if(!f) return;
      statusEl.textContent='Lendo arquivo';
      statusEl.classList.remove('error','success');
      try{
        if(f.name.endsWith('.txt')||f.type==='text/plain') editalConteudo=await f.text();
        else if(f.name.endsWith('.pdf')||f.type==='application/pdf') editalConteudo=await lerPDF(f);
        else if(f.name.endsWith('.docx')) editalConteudo=await lerDOCX(f);
        else throw new Error('Formato não suportado');
        editalConteudo=s(editalConteudo);
        editalInfo.style.display='block';
        editalInfo.textContent=`${f.name} carregado, ${(editalConteudo.length/1024).toFixed(1)} KB`;
        statusEl.textContent='';
      }catch(err){
        statusEl.textContent='Erro ao ler arquivo, '+err.message;
        statusEl.classList.add('error');
      }
    });

    numObjetivosSelect.addEventListener('change', e=>{
      const n=parseInt(e.target.value)||0;
      objetivosContainer.innerHTML='';
      if(n>0){
        objetivosSection.classList.add('ativa');
        for(let i=1;i<=n;i++){
          const div=document.createElement('div');
          div.className='objetivo-input-group';
          div.innerHTML=`
            <strong>Objetivo ${i}</strong>
            <input type="text" name="oe_titulo_${i}" placeholder="Título do objetivo ${i}" required>
            <textarea name="oe_descricao_${i}" placeholder="Descrição do objetivo ${i}" required></textarea>
          `;
          objetivosContainer.appendChild(div);
        }
      }else objetivosSection.classList.remove('ativa');
    });

    form.addEventListener('submit', async e=>{
      e.preventDefault();
      if(!editalConteudo){statusEl.textContent='Carregue o edital';statusEl.classList.add('error');return;}
      const nomeProjeto=s(document.getElementById('nomeProjeto').value);
      const descricaoProposta=s(document.getElementById('descricaoProposta').value);
      const n=parseInt(numObjetivosSelect.value)||0;
      if(!nomeProjeto||!descricaoProposta||!n){statusEl.textContent='Preencha todos os campos';statusEl.classList.add('error');return;}

      const objetivosEspecificos=[];
      for(let i=1;i<=n;i++){
        const titulo=s(form[`oe_titulo_${i}`].value);
        const descricao=s(form[`oe_descricao_${i}`].value);
        if(!titulo||!descricao){statusEl.textContent=`Preencha o objetivo ${i}`;statusEl.classList.add('error');return;}
        objetivosEspecificos.push({numero:i,titulo,descricao});
      }

      const payload={
        edital:editalConteudo,
        nomeProjeto,
        descricaoProposta,
        objetivosEspecificos,
        objetivosEspecificosTexto:objetivosToOneLine(objetivosEspecificos)
      };

      try{
        submitBtn.disabled=true;
        statusEl.textContent='Processando com IA';
        statusEl.classList.remove('error','success');

        const r=await fetch(WEBHOOK_URL,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
        if(!r.ok) throw new Error('HTTP '+r.status);
        const raw=await r.text(); // ler uma vez

        const obj=parseMarco(raw);
        gerarXLSX(obj, nomeProjeto);
        statusEl.textContent='XLSX gerado';
        statusEl.classList.add('success');
      }catch(err){
        statusEl.textContent='Erro ao processar resposta, '+err.message;
        statusEl.classList.add('error');
      }finally{
        submitBtn.disabled=false;
      }
    });

    function gerarXLSX(resp, nomeProjeto){
      const marco=resp.marco_logico||{};
      const objetivos=Array.isArray(marco.objetivos_especificos)?marco.objetivos_especificos:[];
      const wb=XLSX.utils.book_new();

      const totalResultados=objetivos.reduce((a,oe)=>a+(oe.resultados?.length||0),0);
      const totalIndicadores=objetivos.reduce((a,oe)=>a+(oe.resultados||[]).reduce((b,r)=>b+(r.indicadores?.length||0),0),0);
      const totalAtividades=objetivos.reduce((a,oe)=>a+(oe.resultados||[]).reduce((b,r)=>b+(r.atividades?.length||0),0),0);

      const resumo=[
        ['PROJETO',nomeProjeto],
        ['OBJETIVO GERAL',marco.objetivo_geral||''],
        ['DATA',new Date().toLocaleDateString('pt-BR')],
        [''],
        ['ESTATÍSTICAS'],
        ['Objetivos',objetivos.length],
        ['Resultados',totalResultados],
        ['Indicadores',totalIndicadores],
        ['Atividades',totalAtividades]
      ];
      XLSX.utils.book_append_sheet(wb,XLSX.utils.aoa_to_sheet(resumo),'Resumo');

      const linhas=[['OE','RESULTADO','INDICADOR','META','ATIVIDADE','LÓGICA','PRAZO','VERIFICAÇÃO']];
      objetivos.forEach(oe=>{
        (oe.resultados||[]).forEach(r=>{
          const inds=r.indicadores||[];
          const atvs=r.atividades||[];
          const n=Math.max(inds.length,atvs.length,1);
          for(let i=0;i<n;i++){
            const ind=inds[i]||{}, atv=atvs[i]||{};
            linhas.push([
              oe.titulo||'',
              r.titulo||'',
              ind.texto||'',
              ind.meta||'',
              atv.descricao||'',
              atv.logica_intervencao||'',
              atv.prazo||'',
              atv.meios_verificacao||''
            ]);
          }
        });
      });
      XLSX.utils.book_append_sheet(wb,XLSX.utils.aoa_to_sheet(linhas),'Marco Lógico');

      const filename=`Marco_Logico_${String(nomeProjeto).replace(/\s+/g,'_')}.xlsx`;
      XLSX.writeFile(wb,filename);
    }
  </script>
</body>
</html>
